# -*- coding: utf-8 -*-
"""ASTR3750_final_project_vish5156_vees3978.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A7SSC-URaZerv1x5elKti7ZkKGt_WMrx
"""

import numpy as np
import matplotlib.pyplot as plt
from math import pi, e
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import pandas as pd
from matplotlib.gridspec import GridSpec, SubplotSpec

"""# HW 5 Question:
a) Calculate T(r) for the Moon assuming the total heat input is spread uniformly through the interior. Use the Moon’s observed average Tsurf .
b) What’s the temperature at the Moon’s center? Use the constants and inputs from the homework solutions. Below we’ll break the moon into ten shells for ease of calculation.

# Question One

# a) (10)

Before coding, write the generic equations for steps 1-4 above, including units. What
are the equations for the volume and surface area of a shell?
"""

# Equations:

# a) T(r) = Tsurf + (pQ/6k)(R**2-r**2)  [Kelvin]

# b) T(Center) = Tsurf + (pQ/6k)(R**2)  [Kelvin]

# F = -k dt/dr                          [Wm^-2]

# Vol Shell = 4/3 pi (R**3-r**3)        [m^3]

# SA shell = 4 pi (R**2+r**2)           [m^2]

#delta_TE = (Q * delta_time) - (-k * drdr * delta_time)   [J] change in thermal energy

#change in thermal energy is perportional to the conducted heat flux.

"""# b) (10)
For a single shell, calculate how long a time step will it take for radioactivity to warm the shell by 100 degrees. Assume no conduction yet.

(The time does not depend on the shell location or thickness, actually.)

Chose this as your time step.
"""

### Constants ###
Rmoon = 1.74e6                          # meters
Rshells = np.linspace(0,Rmoon,11)       # Radius of each zone starting at 0 going out to the outer boudnary

rho = 5500                        # Average Density of the Moon [kg/m^3]
V_moon = (4/3)*pi*(Rmoon**3)      # Volume of the moon
M_cube = rho*1                    # mass of one cube of moon

delta_T = 100
Q = 8e-12                         # [J/skg]

# assume heat capacity of rock
Cp_rock = 800                     # [J/kgK]
# E = Cp * M * Delta_T

Energy = Cp_rock * M_cube * delta_T

Power = Q * M_cube                  # Q*M = [J/s]

timescale = Energy/Power

# seconds to years
sec_year = 3.154e7                # seconds/yr
                                  # seconds *yr/sec = timescale / sec_year
time = timescale / sec_year       # years

Tsurf = 100  # Initial surface temperature

T = np.full_like(Rshells, Tsurf)  # Initial temperature profile


k = 5     # Thermal conductivity [W/mK]

print(f'''
The radius of each zone starting at 0 going out to the outter boundary is {Rshells}

The energy of heat in one cubic meter by 100k is {Energy}

The power in joules per second is {Power}

The timescale is {timescale} and the time is {time:.2e} years''')

"""# c) (10)
Find the heat flux if dT/dR is 100 K over the shell thickness, showing your work.

What is the total heat conducted through the surface of a shell ~halfway to the center?
"""

def planetary_heat(Radius, Tsurf, k, rho, n):
    '''
    This function is meant to help find the heat flux over a shell thickness. The temprature gradiant
    and the heat conducted of a planetary object.

    input:
        Radius = Radius of each shell [array] # m
        Tsurf  = Surface tempriture [float]
        k      = Thermal conductivity of the material [float]
        rho    = desity [float]
        n      = len of array [float]

    output:
        Flux       = Heat flux [float] #W/m^2
        dtdr       = Thermal gradiant [float]
        MassShells = Mass of the shells [array]
        EnergyShells = Energy of the shells [array]

    Note: make sure to check that your answers make sense before moving on

    '''
    dtdr = (Tsurf / Rshells[1] - Rshells[0])

    Flux = (-k * dtdr)

    # Flux at halfway point = sum of heat energy in the first five shells
    # = 5QM
    MassShells = np.zeros(n)
    for i in range(10):
        Volume = (Rshells[i+1]-Rshells[i])*1*1    # units of m^3
        MassShells[i] = (rho*Volume)
    EnergyShells = np.zeros(n)
    for i in range(10):
        EnergyShells[i] = (Q*MassShells[i])

    return Flux, dtdr, MassShells, EnergyShells



Flux, dtdr, MassShells, EnergyShells  = planetary_heat(Rshells, Tsurf, k, rho, 10)

print(f'''
The flux is {Flux} W/m^2

The thermal gradiant is {dtdr}

The mass of the shells are {MassShells}

Total Heat conducted through the surface of a shell halfway to the center = {np.sum(EnergyShells[:5]):.2e} Watts
''')

"""# Question Two
# a) (10)
Start with 10 interior shells, plus one that represents the surface which remains at Tsurf from the homework.

Create an array that gives:
- r at the middle of each shell
- arrays that store values for T of each shell
- dT/dR at the outer edge of each shell
- the conducted flux at the outer edge.

**Assume the interior shells also start at Tsurf.**

Run the code for 10 time steps and print out all arrays NEATLY and verify that your code is working by calculating a timestep by hand for a single shell.
"""

# Function to perform time steps with the given time scale
def interior_time_steps(num_steps, max_time, current_day):
    """
    This function is meant to perform time steps with a given time scale.

    inputs:
      num_steps = number of desired steps [float]
      max_time = length of time for the steps to span [float - years]
      current_day = the time since formation [float - years]

    outputs:
      time_values = the values for the time that passed
      temperature_profiles = conduction flux
      closest_time_step = the time step that is closest to the current day
      dTdr = thermal gradient
    """
    # replacable arrays
    T = np.full(len(Rshells), Tsurf)

    temperature_profiles = []
    total_heat_profiles = []
    time_values = []

    # Calculate time scale based on the desired maximum time
    time_scale = max_time / num_steps

    for step in range(num_steps):
        dTdr = np.zeros(len(T))
        total_heat_per_shell = np.zeros(len(T))

        # Updated interior temperatures plus the heat conducted for each shell
        for i in range(1, len(T)):
            r_out = Rshells[-i + 1] if i < 0 else 0
            r_in = Rshells[-i - 1] if i > len(T) + 1 else Rshells[i]
            dTdr[i] = (Tsurf / (r_out - r_in))

            # Updated
            total_heat_per_shell[i] = -k * (T[i] - T[i-1]) / (Rshells[i] - Rshells[i-1])

            # temperature
            T[i] = max(0, T[i] + ((rho * Q) / (6 * k)) * ((r_out**2) - (r_in**2)) * time_scale * dTdr[i])

        # Additional cooling based on EnergyShells
    for i in range(len(T) - 1):
        MassShell = rho * (4/3) * np.pi * (Rshells[i+1]**3 - Rshells[i]**3)  # Mass of the shell
        EnergyShell = Q * MassShell  # Energy associated with the shell

        # Convert joules to Kelvin
        cooling_factor = EnergyShell / (1.38e-23)  # 1 K = 1.38e-23 J

        # Subtract cooling factor from temperature
        T[i] = max(0, T[i] - cooling_factor)
        # Save the current temperature and total heat profiles
        temperature_profiles.append(np.copy(T))
        total_heat_profiles.append(np.copy(total_heat_per_shell))

        # time and save
        current_time = time_values[-1] + time_scale if time_values else 0.0
        time_values.append(current_time + time_scale)

    # Find the time step closest to the current day
    closest_time_step = np.argmin(np.abs(np.array(time_values) - current_day))

    return time_values, temperature_profiles, total_heat_profiles, closest_time_step, dTdr

def plot_max_point(ax, r_values, profile, label):
    '''
    This function was kind of just a checking measure

        input:
            ax = sub plot
            r_values = radius values
            profiles = tempratures
            label = label for the max point

        output:
            generated plotted point of the max temprature value!!!!
    '''
    max_temp_index = np.argmax(profile) # finds the largest value in an array
    max_temp = profile[max_temp_index]
    max_radius = r_values[max_temp_index]

    ax.plot(max_radius, max_temp, 'ro', label=f'Max Temp: {max_temp:.2f} K\nat r = {max_radius:.2e} m')

# Maximum time
max_time = 3.17e8

# Number of time steps
num_steps = 10

# Current day
current_day = 4.5e9  # Assuming the moon is about 4.5 billion years old


# Simulate 10 time steps with the given maximum time
times, profiles, total_heat_profiles, closest_time_step, dtdr = interior_time_steps(num_steps, max_time, current_day)

import pandas as pd

# Determine the minimum length among arrays
min_length = min(len(Rshells), len(profiles), len(dtdr), len(total_heat_profiles))

# Create a DataFrame
df = pd.DataFrame({
    "R at the middle of each shell": Rshells[:min_length],
    "Arrays that store values for T of each shell": profiles[:min_length],
    "dT/dR at the outer edge of each shell": dtdr[:min_length],
    "The conducted flux at the outer edge": [total_heat_profiles[i][-1] for i in range(min_length)]
})

# Display the DataFrame
print(df)

"""# b) (10)

**Create plots of T(r) and dT/dR showing how the interior warms up of 10 timesteps.**
"""

# creating a subplot
fig = plt.figure(figsize=(12, 10), constrained_layout=True)
gs = GridSpec(2, 2, figure=fig, height_ratios=[3, 1], width_ratios=[2, 1])

# Plot Temperature Profiles
ax0 = fig.add_subplot(gs[0, :])
ax0.set_title('Temperature Profile Over Time')
for step, (time, profile) in enumerate(zip(times, profiles)):
    label = f'Time Step {step} (Time: {time:.2e} years)'
    if step == closest_time_step:
        ax0.plot(Rshells[::-1], profile, label=label, linewidth=2, linestyle='dashed')  # Reverse the order of Rshells
    else:
        ax0.plot(Rshells[::-1], profile, label=label)  # Reverse the order of Rshells

ax0.set_ylabel('Temperature (K)')
ax0.set_xlabel('Radius (m)')
ax0.legend(loc='center left', bbox_to_anchor=(1, 0.5))

# Subplots for dT/dR and Total Heat Conducted
ax1 = fig.add_subplot(gs[1, 0])
ax2 = fig.add_subplot(gs[1, 1])

# Plot dT/dR at Outer Edge Over Time
ax1.set_title('dT/dR at Outer Edge')
ax1.plot(Rshells, dtdr)
ax1.set_xlabel('Radius (m)')
ax1.set_ylabel('dT/dR')

# Plot Total Heat Conducted Through the Surface of Each Shell Over Time
ax2.set_title('Total Heat Conducted Through the Surface of Each Shell Over Time')
for step, (time, total_heat_profile) in enumerate(zip(times, total_heat_profiles)):
    label = f'Time Step {step} (Time: {time:.2e} years)'
    ax2.plot(Rshells[::-1], total_heat_profile, label=label)  # Reverse the order of Rshells

ax2.set_xlabel('Radius (m)')
ax2.set_ylabel('Total Heat Conducted (W/m^2)')
ax2.legend(loc='center left', bbox_to_anchor=(1, 0.5))

plt.show()

"""#Do your plots make sense?

These plots do make sense!

Without conduction, as heat makes its way from the interior through the surface of the Moon, the core cannot increase in temperature since no energy is being recycled. This way, the core continues to output flux into the outer layers over time and thus the change in temperature from layer to layer reaches equilibrium as the flux from the core reaches the outer layers.

Also, dtdr at the core should be ssignificantly higher in magnitude than at the surface, as the most flux is coming from the core for all times.

Furthermore, the total heat conducted through the surface of each shell over time, reasonably, should be the same at each layer for each timestep, as the Power per unit mass in each shell stays the same since the mass of each shell does not change.

# c) (10) OPTIONAL

**Create an animation showing how the warming continues until a steady-state profile is reached.**
"""

# Analytic steady-state solution (replace with actual formula)
steady_state_profile = np.linspace(Tsurf, 0, len(Rshells))

# Set up the plot
fig, axs = plt.subplots(2, figsize=(10, 8))
fig.suptitle('Evolution of Temperature Profile', fontsize=16)

axs[0].set_xlabel('Radius (m)')
axs[0].set_ylabel('Temperature (K)')
axs[0].set_xlim(min(Rshells), max(Rshells))
axs[0].set_ylim(0, Tsurf)
axs[0].legend(loc='upper right')

axs[1].set_xlabel('Time (years)')
axs[1].set_ylabel('Surface Temperature (K)')
axs[1].set_xlim(0, max_time)
axs[1].set_ylim(0, Tsurf)

# Initialize plots
line1, = axs[0].plot([], [], label='Evolving Profile', color='blue')
line2, = axs[0].plot([], [], '--', label='Steady-State Profile', color='red')
line3, = axs[1].plot([], [], color='green')

# Function to initialize the plot
def init():
    line1.set_data([], [])
    line2.set_data([], [])
    line3.set_data([], [])
    return line1, line2, line3

# Function to update the plot for each animation frame
def update(frame):
    axs[0].clear()
    axs[0].plot(Rshells[::-1], profiles[frame], label='Evolving Profile', color='blue')
    axs[0].plot(Rshells[::-1], steady_state_profile, '--', label='Steady-State Profile', color='red')
    axs[0].set_xlabel('Radius (m)')
    axs[0].set_ylabel('Temperature (K)')
    axs[0].legend()

    axs[1].clear()
    axs[1].plot(times[:frame + 1], [profile[-1] for profile in profiles[:frame + 1]], color='green')
    axs[1].set_xlabel('Time (years)')
    axs[1].set_ylabel('Surface Temperature (K)')

    return line1, line2, line3

# Create the animation
animation = FuncAnimation(fig, update, frames=len(times), init_func=init, blit=True, interval=500, repeat=False)

# Display the animation in the notebook
display(HTML(animation.to_jshtml()))

"""**Compare your profile to the analytic solution in the homework, and comment.
Does the total heat flux transported to the surface equal that created from radioactivity?**

The temperature at the Moon's center in the homework showed a value of 1830 Kelvin. This model we have created gives an internal core temperature of 8000000 Kelvin, which is multiple magnitudes larger than that of the homework.

I don't think the total heat flux transported to the surface is exactly equal to that created by radioactivity, for the totaly flux from radioactivity dissipates throughout the shells.
"""



"""d)"""

### Constants ###
Rearth = 6.37e6                         # meters
Rshells = np.linspace(0,Rearth,11)       # Radius of each zone starting at 0 going out to the outer boudnary

# Assuming the amount of U-238 distributed throughout the volume of the Moon #
rho = 5500                        # Average Density of the Earth [kg/m^3]
V_moon = (4/3)*pi*(Rearth**3)      # Volume of the moon
M_cube = rho*1                    # mass of one cube of moon

delta_T = 100
Q = 8e-12                         # [J/skg]

# assume heat capacity of rock
Cp_rock = 800                     # [J/kgK]
# E = Cp * M * Delta_T

Energy = Cp_rock * M_cube * delta_T

Power = Q * M_cube                  # Q*M = [J/s]

timescale = Energy/Power

# seconds to years
sec_year = 3.154e7                # seconds/yr
                                  # seconds *yr/sec = timescale / sec_year
time = timescale / sec_year       # years

Tsurf = 288  # Initial surface temperature [K]

T = np.full_like(Rshells, Tsurf)  # Initial temperature profile


k = 3     # Thermal conductivity [W/mK] - average for the lower mantel of the earth from an AGU 2014 publication

## Earth ###
def interior_time_steps(num_steps, max_time, current_day):
    """
    This function is meant to perform time steps with a given time scale.

    inputs:
      num_steps = number of desired steps [float]
      max_time = length of time for the steps to span [float - years]
      current_day = the time since formation [float - years]

    outputs:
      time_values = the values for the time that passed
      temperature_profiles = conduction flux
      closest_time_step = the time step that is closest to the current day
      dTdr = thermal gradient
    """
    # replacable arrays
    T = np.full(len(Rshells), Tsurf)

    temperature_profiles = []
    total_heat_profiles = []
    time_values = []

    # Calculate time scale based on the desired maximum time
    time_scale = max_time / num_steps

    for step in range(num_steps):
        dTdr = np.zeros(len(T))
        total_heat_per_shell = np.zeros(len(T))

        # Updated interior temperatures plus the heat conducted for each shell
        for i in range(1, len(T)):
            r_out = Rshells[-i + 1] if i < 0 else 0
            r_in = Rshells[-i - 1] if i > len(T) + 1 else Rshells[i]
            dTdr[i] = (Tsurf / (r_out - r_in))

            # Updated
            total_heat_per_shell[i] = -k * (T[i] - T[i-1]) / (Rshells[i] - Rshells[i-1])

            # temperature
            T[i] = max(0, T[i] + ((rho * Q) / (6 * k)) * ((r_out**2) - (r_in**2)) * time_scale * dTdr[i])

        # Additional cooling based on EnergyShells
    for i in range(len(T) - 1):
        MassShell = rho * (4/3) * np.pi * (Rshells[i+1]**3 - Rshells[i]**3)  # Mass of the shell
        EnergyShell = Q * MassShell  # Energy associated with the shell

        # Convert joules to Kelvin
        cooling_factor = EnergyShell / (1.38e-23)  # 1 K = 1.38e-23 J

        # Subtract cooling factor from temperature
        T[i] = max(0, T[i] - cooling_factor)
        # Save the current temperature and total heat profiles
        temperature_profiles.append(np.copy(T))
        total_heat_profiles.append(np.copy(total_heat_per_shell))

        # time and save
        current_time = time_values[-1] + time_scale if time_values else 0.0
        time_values.append(current_time + time_scale)

    # Find the time step closest to the current day
    closest_time_step = np.argmin(np.abs(np.array(time_values) - current_day))

    return time_values, temperature_profiles, total_heat_profiles, closest_time_step, dTdr

def plot_max_point(ax, r_values, profile, label):
    '''
    This function was kind of just a checking measure

        input:
            ax = sub plot
            r_values = radius values
            profiles = tempratures
            label = label for the max point

        output:
            generated plotted point of the max temprature value!!!!
    '''
    max_temp_index = np.argmax(profile) # finds the largest value in an array
    max_temp = profile[max_temp_index]
    max_radius = r_values[max_temp_index]

    ax.plot(max_radius, max_temp, 'ro', label=f'Max Temp: {max_temp:.2f} K\nat r = {max_radius:.2e} m')

# Maximum time
max_time = 4.5e9 #years

# Number of time steps
num_steps = 10

# Current day
current_day = 4.54e9  # Assuming the moon is about 4.5 billion years old


# Simulate 10 time steps with the given maximum time
times, profiles, total_heat_profiles, closest_time_step, dtdr = interior_time_steps(num_steps, max_time, current_day)

# Determine the minimum length among arrays
min_length = min(len(Rshells), len(profiles), len(dtdr), len(total_heat_profiles))

# Create a DataFrame
df = pd.DataFrame({
    "R at the middle of each shell": Rshells[:min_length],
    "Arrays that store values for T of each shell": profiles[:min_length],
    "dT/dR at the outer edge of each shell": dtdr[:min_length],
    "The conducted flux at the outer edge": [total_heat_profiles[i][-1] for i in range(min_length)]
})

# Display the DataFrame
print(df)

# creating a subplot
fig = plt.figure(figsize=(12, 10), constrained_layout=True)
gs = GridSpec(2, 2, figure=fig, height_ratios=[3, 1], width_ratios=[2, 1])

# Plot Temperature Profiles
ax0 = fig.add_subplot(gs[0, :])
ax0.set_title('Temperature Profile Over Time')
for step, (time, profile) in enumerate(zip(times, profiles)):
    label = f'Time Step {step} (Time: {time:.2e} years)'
    if step == closest_time_step:
        ax0.plot(Rshells[::-1], profile, label=label, linewidth=2, linestyle='dashed')  # Reverse the order of Rshells
    else:
        ax0.plot(Rshells[::-1], profile, label=label)  # Reverse the order of Rshells

ax0.set_ylabel('Temperature (K)')
ax0.legend(loc='center left', bbox_to_anchor=(1, 0.5))

# Subplots for dT/dR and Total Heat Conducted
ax1 = fig.add_subplot(gs[1, 0])
ax2 = fig.add_subplot(gs[1, 1])

# Plot dT/dR at Outer Edge Over Time
ax1.set_title('dT/dR at Outer Edge Over Time')
ax1.plot(Rshells, dtdr)
ax1.set_xlabel('Radius (m)')
ax1.set_ylabel('dT/dR')

# Plot Total Heat Conducted Through the Surface of Each Shell Over Time
ax2.set_title('Heat Conducted Through the Surface of Each Shell Over Time')
for step, (time, total_heat_profile) in enumerate(zip(times, total_heat_profiles)):
    label = f'Time Step {step} (Time: {time:.2e} years)'
    ax2.plot(Rshells[::-1], total_heat_profile, label=label)  # Reverse the order of Rshells

ax2.set_xlabel('Radius (m)')
ax2.set_ylabel('Total Heat Conducted (W/m^2)')
ax2.legend(loc='center left', bbox_to_anchor=(1, 0.5))

plt.show()

# Analytic steady-state solution (replace with actual formula)
steady_state_profile = np.linspace(Tsurf, 0, len(Rshells))

# Set up the plot
fig, axs = plt.subplots(2, figsize=(10, 8))
fig.suptitle('Evolution of Temperature Profile', fontsize=16)

axs[0].set_xlabel('Radius (m)')
axs[0].set_ylabel('Temperature (K)')
axs[0].set_xlim(min(Rshells), max(Rshells))
axs[0].set_ylim(0, Tsurf)
axs[0].legend(loc='upper right')

axs[1].set_xlabel('Time (years)')
axs[1].set_ylabel('Surface Temperature (K)')
axs[1].set_xlim(0, max_time)
axs[1].set_ylim(0, Tsurf)

# Initialize plots
line1, = axs[0].plot([], [], label='Evolving Profile', color='blue')
line2, = axs[0].plot([], [], '--', label='Steady-State Profile', color='red')
line3, = axs[1].plot([], [], color='green')

# Function to initialize the plot
def init():
    line1.set_data([], [])
    line2.set_data([], [])
    line3.set_data([], [])
    return line1, line2, line3

# Function to update the plot for each animation frame
def update(frame):
    axs[0].clear()
    for step, (time, profile) in enumerate(zip(times, profiles)):
        label = f'Time Step {step} (Time: {time:.2e} years)'
        if step == closest_time_step:
            axs[0].plot(Rshells[::-1], profiles[frame], linewidth=2, linestyle='dashed', color='blue')  # Reverse the order of Rshells
        else:
            axs[0].plot(Rshells[::-1], profiles[frame],color='blue')  # Reverse the order of Rshells

    axs[0].plot(Rshells, steady_state_profile, '--', label='Steady-State Profile', color='red')
    axs[0].set_xlabel('Radius (m)')
    axs[0].set_ylabel('Temperature (K)')
    axs[0].legend()

    axs[1].clear()
    axs[1].plot(times[:frame + 1], [profile[-1] for profile in profiles[:frame + 1]], color='green')
    axs[1].set_xlabel('Time (years)')
    axs[1].set_ylabel('Surface Temperature (K)')

    return line1, line2, line3

# Create the animation
animation = FuncAnimation(fig, update, frames=len(times), init_func=init, blit=True, interval=500, repeat=False)

# Display the animation in the notebook
display(HTML(animation.to_jshtml()))

